// File generated by Prisma Client Rust. DO NOT EDIT

pub static DATAMODEL_STR : & 'static str = include_str ! ("/Users/luukmeier/Documents/CMD/Afstuderen/product/contextual-notes/src-tauri/prisma/schema.prisma") ; static DATABASE_STR : & 'static str = "sqlite" ; use :: prisma_client_rust :: migrations :: include_dir ; pub static MIGRATIONS_DIR : & :: prisma_client_rust :: migrations :: include_dir :: Dir = & :: prisma_client_rust :: migrations :: include_dir :: include_dir ! ("/Users/luukmeier/Documents/CMD/Afstuderen/product/contextual-notes/src-tauri/prisma/migrations") ; pub use _prisma :: * ; use prisma_client_rust :: scalar_types :: * ; pub mod _prisma { use super :: * ; pub struct PrismaClientBuilder { url : Option < String > , action_notifier : :: prisma_client_rust :: ActionNotifier , } impl PrismaClientBuilder { fn new () -> Self { Self { url : None , action_notifier : :: prisma_client_rust :: ActionNotifier :: new () } } pub fn with_url (mut self , url : String) -> Self { self . url = Some (url) ; self } pub async fn build (self) -> Result < PrismaClient , :: prisma_client_rust :: NewClientError > { let internals = :: prisma_client_rust :: PrismaClientInternals :: new (self . url , self . action_notifier , super :: DATAMODEL_STR) . await ? ; Ok (PrismaClient (internals)) } } pub struct PrismaClient (:: prisma_client_rust :: PrismaClientInternals) ; impl :: std :: fmt :: Debug for PrismaClient { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . debug_struct ("PrismaClient") . finish () } } impl PrismaClient { pub fn _builder () -> PrismaClientBuilder { PrismaClientBuilder :: new () } pub fn _query_raw < T : :: prisma_client_rust :: Data > (& self , query : :: prisma_client_rust :: Raw) -> :: prisma_client_rust :: QueryRaw < T > { :: prisma_client_rust :: QueryRaw :: new (& self . 0 , query , super :: DATABASE_STR ,) } pub fn _execute_raw (& self , query : :: prisma_client_rust :: Raw) -> :: prisma_client_rust :: ExecuteRaw { :: prisma_client_rust :: ExecuteRaw :: new (& self . 0 , query , super :: DATABASE_STR ,) } pub async fn _batch < 'batch , T : :: prisma_client_rust :: BatchContainer < 'batch , Marker > , Marker > (& self , queries : T) -> :: prisma_client_rust :: Result << T as :: prisma_client_rust :: BatchContainer < 'batch , Marker >> :: ReturnType > { :: prisma_client_rust :: batch (queries , & self . 0) . await } pub fn _transaction (& self) -> :: prisma_client_rust :: TransactionBuilder < Self > { :: prisma_client_rust :: TransactionBuilder :: _new (self , & self . 0) } pub async fn _migrate_deploy (& self) -> Result < () , :: prisma_client_rust :: migrations :: MigrateDeployError > { let res = :: prisma_client_rust :: migrations :: migrate_deploy (super :: DATAMODEL_STR , super :: MIGRATIONS_DIR , & self . 0 . url ()) . await ; :: prisma_client_rust :: tokio :: time :: sleep (core :: time :: Duration :: from_millis (1)) . await ; res } pub async fn _migrate_resolve (& self , migration : & str) -> Result < () , :: prisma_client_rust :: migrations :: MigrateResolveError > { :: prisma_client_rust :: migrations :: migrate_resolve (migration , super :: DATAMODEL_STR , super :: MIGRATIONS_DIR , & self . 0 . url () ,) . await } pub fn _db_push (& self) -> :: prisma_client_rust :: migrations :: DbPush { :: prisma_client_rust :: migrations :: db_push (super :: DATAMODEL_STR , & self . 0 . url ()) } pub fn user (& self) -> super :: user :: Actions { super :: user :: Actions { client : & self . 0 , } } } impl :: prisma_client_rust :: PrismaClient for PrismaClient { fn internals (& self) -> & :: prisma_client_rust :: PrismaClientInternals { & self . 0 } fn internals_mut (& mut self) -> & mut :: prisma_client_rust :: PrismaClientInternals { & mut self . 0 } fn with_tx_id (& self , tx_id : Option < :: prisma_client_rust :: query_core :: TxId >) -> Self { Self (self . 0 . with_tx_id (tx_id)) } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum TransactionIsolationLevel { # [serde (rename = "Serializable")] Serializable } impl ToString for TransactionIsolationLevel { fn to_string (& self) -> String { match self { Self :: Serializable => "Serializable" . to_string () } } } impl :: prisma_client_rust :: TransactionIsolationLevel for TransactionIsolationLevel { } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum UserScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "email")] Email , # [serde (rename = "name")] Name } impl ToString for UserScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: Email => "email" . to_string () , Self :: Name => "name" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum SortOrder { # [serde (rename = "asc")] Asc , # [serde (rename = "desc")] Desc } impl ToString for SortOrder { fn to_string (& self) -> String { match self { Self :: Asc => "asc" . to_string () , Self :: Desc => "desc" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum NullsOrder { # [serde (rename = "first")] First , # [serde (rename = "last")] Last } impl ToString for NullsOrder { fn to_string (& self) -> String { match self { Self :: First => "first" . to_string () , Self :: Last => "last" . to_string () } } } impl Into < :: prisma_client_rust :: PrismaValue > for SortOrder { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { SortOrder :: Asc => :: prisma_client_rust :: PrismaValue :: String ("asc" . to_string ()) , SortOrder :: Desc => :: prisma_client_rust :: PrismaValue :: String ("desc" . to_string ()) , } } } pub mod read_filters { use super :: * ; # [derive (Debug , Clone)] pub enum IntFilter { Equals (Int) , InVec (Vec < Int >) , NotInVec (Vec < Int >) , Lt (Int) , Lte (Int) , Gt (Int) , Gte (Int) , Not (Int) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for IntFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Int (value as i64)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Int (value as i64)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))]) } } } # [derive (Debug , Clone)] pub enum StringFilter { Equals (String) , InVec (Vec < String >) , NotInVec (Vec < String >) , Lt (String) , Lte (String) , Gt (String) , Gte (String) , Contains (String) , StartsWith (String) , EndsWith (String) , Not (String) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for StringFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Contains (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: StartsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: EndsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) } } } # [derive (Debug , Clone)] pub enum StringNullableFilter { Equals (Option < String >) , InVec (Vec < String >) , NotInVec (Vec < String >) , Lt (String) , Lte (String) , Gt (String) , Gte (String) , Contains (String) , StartsWith (String) , EndsWith (String) , Not (Option < String >) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for StringNullableFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Contains (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: StartsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: EndsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) } } } } pub mod write_params { use super :: * ; # [derive (Debug , Clone)] pub enum IntParam { Set (Int) , Increment (Int) , Decrement (Int) , Multiply (Int) , Divide (Int) } impl Into < :: prisma_client_rust :: PrismaValue > for IntParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => :: prisma_client_rust :: PrismaValue :: Int (value as i64) , Self :: Increment (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))]) , Self :: Decrement (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))]) , Self :: Multiply (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))]) , Self :: Divide (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))]) } } } # [derive (Debug , Clone)] pub enum StringParam { Set (String) } impl Into < :: prisma_client_rust :: PrismaValue > for StringParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => :: prisma_client_rust :: PrismaValue :: String (value) } } } # [derive (Debug , Clone)] pub enum StringNullableParam { Set (Option < String >) } impl Into < :: prisma_client_rust :: PrismaValue > for StringNullableParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null) } } } } } pub mod user { use super :: { _prisma :: * , * } ; pub const NAME : & str = "User" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: IntFilter) , Email (super :: _prisma :: read_filters :: StringFilter) , Name (super :: _prisma :: read_filters :: StringNullableFilter) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Email (value) => (email :: NAME , value . into ()) , Self :: Name (value) => (name :: NAME , value . into ()) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { EmailEquals (String) , IdEquals (Int) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: EmailEquals (value) => ("email" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) , UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: Int (value as i64))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , Email (super :: SortOrder) , Name (super :: SortOrder) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: Email (param) => ("email" , param . into ()) , Self :: Name (param) => ("name" , param . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: IntParam) , Email (super :: _prisma :: write_params :: StringParam) , Name (super :: _prisma :: write_params :: StringNullableParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Email (value) => (email :: NAME , value . into ()) , Self :: Name (value) => (name :: NAME , value . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: IntParam) , Email (super :: _prisma :: write_params :: StringParam) , Name (super :: _prisma :: write_params :: StringNullableParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: Email (value) => ("email" , value . into ()) , Self :: Name (value) => ("name" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_user , select , crate :: db :: user , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "email")] email : email :: Type , # [serde (rename = "name")] name : name :: Type } , [(id , Scalar) , (email , Scalar) , (name , Scalar)]) ; pub enum SelectParam { Id (id :: Select) , Email (email :: Select) , Name (name :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Email (data) => data . into () , Self :: Name (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_user , include , crate :: db :: user , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "email")] email : email :: Type , # [serde (rename = "name")] name : name :: Type } , []) ; pub enum IncludeParam { Id (id :: Include) , Email (email :: Include) , Name (name :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Email (data) => data . into () , Self :: Name (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub email : String , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . user () . create (self . email , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([email :: set (self . email)]) ; self . _params } } pub fn create (email : String , _params : Vec < SetParam >) -> Create { Create { email , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub email : String , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . user () . create_unchecked (self . email , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([email :: set (self . email)]) ; self . _params } } pub fn create_unchecked (email : String , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { email , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (email :: NAME) , :: prisma_client_rust :: sel (name :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename = "User" , crate = "prisma_client_rust::specta")] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "email")] pub email : email :: Type , # [serde (rename = "name")] pub name : name :: Type } impl Data { } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_user , crate :: db :: user , struct Data { # [serde (rename = "id")] pub id : crate :: db :: user :: id :: Type , # [serde (rename = "email")] pub email : crate :: db :: user :: email :: Type , # [serde (rename = "name")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub name : crate :: db :: user :: name :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_user_filter , crate :: db :: user , [(id , Scalar) , (email , Scalar) , (name , Scalar)]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , email : String , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { _params . extend ([email :: set (email)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , email : String , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { _params . extend ([email :: set (email)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod email { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "email" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : String) -> T { Equals (value) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: EmailEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Email (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Email , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Email (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Email (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Email (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Email (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Email (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Email (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Email (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : Int) -> T { Equals (value) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , Id , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : Int) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod name { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "name" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : Option < String >) -> T { Equals (value) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Name (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , Name , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Name (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Name (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : Option < String >) -> T { Set (value) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Name (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Name (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Name (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Name (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Name (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } }